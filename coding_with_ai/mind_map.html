<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mind Map MVP</title>
  <style>
    :root{
      --bg:#28262c;
      --c1:#998fc7; /* lavender */
      --c2:#d4c2fc; /* light lavender */
      --c3:#f9f5ff; /* near-white */
      --c4:#14248a; /* deep blue */
      --text:#ffffff;
      --ghost:#ffffff40;
      --accent:#ffffffb3;
      --toolbar:#37343c;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}

    .toolbar{
      position:fixed; inset:12px 12px auto 12px; display:flex; gap:8px; align-items:center;
      background:var(--toolbar); border:1px solid #00000040; border-radius:12px; padding:8px 10px;
      box-shadow:0 6px 16px #00000040; z-index:10;
    }
    .toolbar button{
      background:#4a4650; color:#fff; border:1px solid #00000055; padding:8px 12px; border-radius:10px;
      cursor:pointer; font-weight:600; letter-spacing:.2px; transition:transform .06s ease, opacity .15s ease;
    }
    .toolbar button:hover{transform:translateY(-1px)}
    .toolbar button:active{transform:translateY(0)}
    .toolbar .hint{opacity:.7; font-size:12px; margin-left:4px}
    .toolbar .spacer{ flex:1 1 auto; }
    .toolbar .title{ min-width:220px; max-width:420px; margin-left:12px; padding:6px 10px; border-radius:10px; border:1px solid #ffffff22; background:#00000022;
      font-size:18px; font-weight:600; color:var(--text); outline:none; }
    .toolbar .title:empty::before{ content:attr(data-placeholder); opacity:.5; font-weight:500; }

    #board{ position:fixed; inset:0; overflow:hidden; user-select:none; }
    #edges{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }
    #edges path{ stroke:var(--accent); stroke-width:2; fill:none; }

    .bubble{
      position:absolute; min-width:160px; max-width:320px; min-height:56px; padding:12px;
      border-radius:16px; border:2px solid transparent; outline:none; color:var(--text);
      box-shadow:0 8px 24px #00000050; line-height:1.25; cursor:text; user-select:text; -webkit-user-select:text;
    }
    .bubble[data-color="0"]{ background:var(--c1); }
    .bubble[data-color="1"]{ background:var(--c2); }
    .bubble[data-color="2"]{ background:var(--c3); }
    .bubble[data-color="3"]{ background:var(--c4); }
    .bubble{ text-shadow: 0 1px 0 #00000025; }
    .bubble:focus{ border-color:var(--accent); }

    .bubble .text{
      position:relative; display:block; min-height:32px; padding-right:48px; padding-left:28px;
      white-space:pre-wrap; word-wrap:break-word; outline:none;
    }

    .link-handle{
      position:absolute; right:6px; top:50%; transform:translateY(-50%);
      width:22px; height:22px; border-radius:50%;
      background:#00000033; border:1px solid #ffffff55; pointer-events:auto; cursor:grab;
      display:grid; place-items:center; font-size:13px; color:#fff; user-select:none;
    }
    .delete-btn{
      position:absolute; left:6px; top:6px; width:18px; height:18px; border-radius:50%;
      background:#00000038; border:1px solid #ffffff55; color:#fff; font-size:12px; line-height:16px; text-align:center; cursor:pointer; user-select:none;
    }
    .delete-btn:hover{ background:#00000055 }
    .link-handle:active{ cursor:grabbing }
    .link-handle:active{ cursor:grabbing }
    .link-hint{ position:absolute; bottom:-18px; right:6px; font-size:10px; opacity:.6; pointer-events:none; }

    /* Ghost bubble shown during drag-to-link */
    .ghost{
      position:absolute; min-width:200px; height:72px; padding:12px; border-radius:16px;
      background:transparent; border:2px dotted var(--accent); color:var(--text);
      pointer-events:none; box-shadow:none; opacity:.9;
    }
    .ghost.open{ border-style:solid; }

    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
  </style>
</head>
<body>
  <div class="toolbar">
    <button id="importBtn" title="Import a JSON map">Import</button>
    <input id="fileInput" type="file" accept="application/json" class="sr-only" />
    <button id="exportBtn" title="Download current map as JSON">Export</button>
    <button id="clearBtn" title="Clear current map">Clear</button>
    <div class="hint">Shift+Drag on a bubble or use the ⟳ handle to create a linked thought.</div>
    <div class="spacer"></div>
    <div id="title" class="title" contenteditable="true" data-placeholder="Enter title here"></div>
  </div>

  <div id="board" aria-label="Mind map canvas">
    <svg id="edges" aria-hidden="true"></svg>
    <!-- bubbles injected here -->
  </div>

  <script>
    (function(){
      const BOARD = document.getElementById('board');
      const EDGES_SVG = document.getElementById('edges');
      const IMPORT_BTN = document.getElementById('importBtn');
      const FILE_INPUT = document.getElementById('fileInput');
      const EXPORT_BTN = document.getElementById('exportBtn');
      const CLEAR_BTN = document.getElementById('clearBtn');
      const TITLE_EL = document.getElementById('title');
    
      const STORAGE_KEY = 'mindmap-mvp-v1';
      const COLORS = ['#998fc7','#d4c2fc','#f9f5ff','#14248a'];
      const DEFAULT_SIZE = { w: 220, h: 72 };
      const MARGIN = 16;
    
      let state = { nodes:{}, edges:[], nextColor:0, title:'' };
    
      let linkDrag = { active:false, sourceId:null, ghostEl:null, tempPath:null, openSpace:false };
      let moveDrag = { active:false, id:null, offsetX:0, offsetY:0 };
    
      const uuid = () => 'n' + Math.random().toString(36).slice(2,7) + Date.now().toString(36);
      const boardRect = () => BOARD.getBoundingClientRect();
      const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
    
      const isEditing = () => document.activeElement && document.activeElement.classList && document.activeElement.classList.contains('text');
      const blurActiveText = () => { if(isEditing()) document.activeElement.blur(); };
    
      function makeBubbleEl(node){
        const el = document.createElement('div');
        el.className = 'bubble';
        el.dataset.id = node.id;
        el.dataset.color = String(node.colorIdx);
        el.style.left = node.x + 'px';
        el.style.top  = node.y + 'px';
        el.style.width = node.w + 'px';
        el.style.minHeight = node.h + 'px';
    
        // editable inner text
        const textEl = document.createElement('div');
        textEl.className = 'text';
        textEl.contentEditable = 'true';
        textEl.textContent = node.text || '';
        el.appendChild(textEl);
    
        // link handle (hidden until hover)
        const handle = document.createElement('div');
        handle.className = 'link-handle';
        handle.title = 'Drag to create a linked thought';
        handle.textContent = '⟳';
        handle.style.opacity = '0';
        handle.style.pointerEvents = 'none';
        el.appendChild(handle);
    
        const hint = document.createElement('div');
        hint.className = 'link-hint';
        hint.textContent = 'link';
        hint.setAttribute('aria-hidden','true');
        hint.style.opacity = '0';
        hint.style.pointerEvents = 'none';
        el.appendChild(hint);
    
        // delete × (hidden until hover)
        const del = document.createElement('div');
        del.className = 'delete-btn';
        del.title = 'Delete this thought';
        del.textContent = '×';
        del.style.opacity = '0';
        del.style.pointerEvents = 'none';
        del.addEventListener('click', (ev)=>{ ev.stopPropagation(); removeNode(node.id); });
        el.appendChild(del);
    
        // hover show/hide controls
        el.addEventListener('mouseenter', () => {
          handle.style.opacity = '1'; handle.style.pointerEvents = 'auto';
          del.style.opacity = '1';    del.style.pointerEvents    = 'auto';
          hint.style.opacity = '1';
        });
        el.addEventListener('mouseleave', () => {
          handle.style.opacity = '0'; handle.style.pointerEvents = 'none';
          del.style.opacity = '0';    del.style.pointerEvents    = 'none';
          hint.style.opacity = '0';
        });
    
        applyTextContrast(textEl, node.colorIdx);
    
        // text -> state
        textEl.addEventListener('input', () => {
          const id = el.dataset.id;
          if(state.nodes[id]){
            state.nodes[id].text = textEl.textContent || '';
            persist();
          }
        });
    
        // Tab/Esc to exit edit mode
        textEl.addEventListener('keydown', (e) => {
          if(e.key === 'Tab'){
            e.preventDefault();
            textEl.blur();
            return;
          }
          if(e.key === 'Escape'){
            const id = el.dataset.id;
            if(el.dataset.fresh === '1'){ removeNode(id); e.preventDefault(); return; }
            textEl.blur();
          }
        });
    
        // mark not-fresh after blur
        textEl.addEventListener('blur', () => { el.dataset.fresh = '0'; });
    
        // link-drag (handle) and Shift+drag anywhere on bubble
        handle.addEventListener('mousedown', (e) => startLinkDrag(e, node.id));
        el.addEventListener('mousedown', (e) => {
          if(e.shiftKey && e.button === 0){ startLinkDrag(e, node.id); }
        });
    
        // free move-drag when not editing text
        el.addEventListener('mousedown', (e) => {
          if(e.button !== 0) return;
          if(e.shiftKey) return;
          if(e.target.closest('.link-handle') || e.target.closest('.delete-btn')) return;
          const t = el.querySelector('.text');
          if(document.activeElement === t) return; // editing
          e.preventDefault();
          startMoveDrag(e, node.id);
        });
    
        return el;
      }
    
      // If editing and user clicks anywhere outside a bubble, just blur (no new bubble).
      document.addEventListener('mousedown', (e) => {
        if(isEditing() && !e.target.closest('.bubble')){
          // don't block toolbar clicks; just blur
          blurActiveText();
        }
      }, true);
    
      // ---------- Link creation ----------
      function startLinkDrag(e, sourceId){
        e.preventDefault();
        if(linkDrag.active) return;
        linkDrag.active = true;
        linkDrag.sourceId = sourceId;
        linkDrag.ghostEl = makeGhost();
        EDGES_SVG.appendChild(linkDrag.tempPath = document.createElementNS('http://www.w3.org/2000/svg','path'));
        document.addEventListener('mousemove', onLinkMove);
        document.addEventListener('mouseup', onLinkUp, { once:true });
      }
      function onLinkMove(e){
        if(!linkDrag.active) return;
        const pos = canvasPos(e.clientX, e.clientY);
        positionGhost(pos.x - DEFAULT_SIZE.w/2, pos.y - DEFAULT_SIZE.h/2);
        linkDrag.openSpace = isOpenSpace(pos.x - DEFAULT_SIZE.w/2, pos.y - DEFAULT_SIZE.h/2, DEFAULT_SIZE.w, DEFAULT_SIZE.h);
        linkDrag.ghostEl.classList.toggle('open', linkDrag.openSpace);
        drawTempLink(linkDrag.sourceId, pos.x, pos.y);
      }
      function onLinkUp(e){
        document.removeEventListener('mousemove', onLinkMove);
        if(!linkDrag.active) return;
        const pos = canvasPos(e.clientX, e.clientY);
        if(linkDrag.openSpace){
          const newNode = createNode(Math.round(pos.x - DEFAULT_SIZE.w/2), Math.round(pos.y - DEFAULT_SIZE.h/2), '', nextColorIdx());
          focusNode(newNode.id);
          createEdge(linkDrag.sourceId, newNode.id);
          persist();
        }
        cleanupLinkDrag();
      }
      function cleanupLinkDrag(){
        linkDrag.active = false;
        linkDrag.sourceId = null;
        if(linkDrag.ghostEl) linkDrag.ghostEl.remove();
        linkDrag.ghostEl = null;
        if(linkDrag.tempPath) linkDrag.tempPath.remove();
        linkDrag.tempPath = null;
      }
    
      // ---------- Move / minimal overlap resolve ----------
      function startMoveDrag(e, id){
        moveDrag.active = true;
        moveDrag.id = id;
        const n = state.nodes[id];
        const pos = canvasPos(e.clientX, e.clientY);
        moveDrag.offsetX = pos.x - n.x;
        moveDrag.offsetY = pos.y - n.y;
        document.addEventListener('mousemove', onMoveDrag);
        document.addEventListener('mouseup', onMoveUp, { once:true });
      }
      function onMoveDrag(e){
        if(!moveDrag.active) return;
        const n = state.nodes[moveDrag.id]; if(!n) return;
        const br = boardRect();
        const pos = canvasPos(e.clientX, e.clientY);
        n.x = clamp(pos.x - moveDrag.offsetX, 0, br.width  - n.w);
        n.y = clamp(pos.y - moveDrag.offsetY, 0, br.height - n.h);
        const el = BOARD.querySelector(`.bubble[data-id="${CSS.escape(moveDrag.id)}"]`);
        if(el){ el.style.left = n.x+'px'; el.style.top = n.y+'px'; }
        redrawEdges();
      }
      function onMoveUp(e){
        document.removeEventListener('mousemove', onMoveDrag);
        if(!moveDrag.active) return;
        const id = moveDrag.id;
        moveDrag.active = false; moveDrag.id = null;
        minimalResolve(id); // nudge just enough to avoid overlaps/bounds
        redrawEdges(); persist();
      }
      function minimalResolve(id){
        const n = state.nodes[id]; if(!n) return;
        const br = boardRect();
        // keep inside bounds first
        n.x = clamp(n.x, 0, br.width  - n.w);
        n.y = clamp(n.y, 0, br.height - n.h);
    
        const maxIters = 50;
        for(let iter=0; iter<maxIters; iter++){
          let moved = false;
    
          // bounds (with margin)
          if(n.x < MARGIN){ n.x = MARGIN; moved = true; }
          if(n.y < MARGIN){ n.y = MARGIN; moved = true; }
          if(n.x + n.w > br.width - MARGIN){ n.x = br.width - MARGIN - n.w; moved = true; }
          if(n.y + n.h > br.height - MARGIN){ n.y = br.height - MARGIN - n.h; moved = true; }
    
          // overlap with others
          const r1 = { x:n.x, y:n.y, w:n.w, h:n.h };
          let bestMove = null;
    
          for(const otherId in state.nodes){
            if(otherId === id) continue;
            const o = state.nodes[otherId];
            const r2 = { x:o.x - MARGIN, y:o.y - MARGIN, w:o.w + 2*MARGIN, h:o.h + 2*MARGIN };
            if(!overlap(r1, r2)) continue;
    
            // minimal displacement options
            const options = [
              { dx: (r2.x - r1.w) - r1.x, dy: 0 },               // move left
              { dx: (r2.x + r2.w) - r1.x, dy: 0 },               // move right
              { dx: 0, dy: (r2.y - r1.h) - r1.y },               // move up
              { dx: 0, dy: (r2.y + r2.h) - r1.y }                // move down
            ];
            for(const op of options){
              const nx = clamp(n.x + op.dx, MARGIN, br.width  - MARGIN - n.w);
              const ny = clamp(n.y + op.dy, MARGIN, br.height - MARGIN - n.h);
              const dist2 = (nx - n.x)*(nx - n.x) + (ny - n.y)*(ny - n.y);
              if(bestMove == null || dist2 < bestMove.dist2){ bestMove = { x:nx, y:ny, dist2 }; }
            }
          }
    
          if(bestMove){ n.x = bestMove.x; n.y = bestMove.y; moved = true; }
          if(!moved) break;
        }
    
        const el = BOARD.querySelector(`.bubble[data-id="${CSS.escape(id)}"]`);
        if(el){ el.style.left = n.x+'px'; el.style.top = n.y+'px'; }
      }
      function overlap(a,b){
        return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
      }
    
      // ---------- Ghost + edges ----------
      function makeGhost(){ const g = document.createElement('div'); g.className = 'ghost'; BOARD.appendChild(g); return g; }
      function positionGhost(l,t){
        const br = boardRect();
        linkDrag.ghostEl.style.left = clamp(l,0,br.width - DEFAULT_SIZE.w)+'px';
        linkDrag.ghostEl.style.top  = clamp(t,0,br.height- DEFAULT_SIZE.h)+'px';
        linkDrag.ghostEl.style.width = DEFAULT_SIZE.w + 'px';
        linkDrag.ghostEl.style.height= DEFAULT_SIZE.h + 'px';
      }
      function drawTempLink(fromId, mx, my){
        const from = state.nodes[fromId]; if(!from || !linkDrag.tempPath) return;
        const p1 = centerOf(from), p2 = {x:mx,y:my};
        linkDrag.tempPath.setAttribute('d', cubicPath(p1, p2));
      }
      const centerOf = n => ({ x:n.x + n.w/2, y:n.y + n.h/2 });
      function cubicPath(p1, p2){
        const dx = (p2.x - p1.x) * 0.5, c = clamp(dx, -160, 160);
        const c1 = { x:p1.x + c, y:p1.y }, c2 = { x:p2.x - c, y:p2.y };
        return `M ${p1.x},${p1.y} C ${c1.x},${c1.y} ${c2.x},${c2.y} ${p2.x},${p2.y}`;
      }
    
      // ---------- Nodes/edges ----------
      function nextColorIdx(){ const i = state.nextColor % COLORS.length; state.nextColor++; return i; }
      function createNode(x,y,text='',colorIdx=nextColorIdx(),id=uuid()){
        const node = { id, x, y, w:DEFAULT_SIZE.w, h:DEFAULT_SIZE.h, text, colorIdx };
        state.nodes[id] = node;
        const el = makeBubbleEl(node);
        el.dataset.fresh = '1';
        BOARD.appendChild(el);
        redrawEdges(); persist();
        return node;
      }
      function removeNode(id){
        state.edges = state.edges.filter(e => e.from !== id && e.to !== id);
        const el = BOARD.querySelector(`.bubble[data-id="${CSS.escape(id)}"]`);
        if(el) el.remove();
        delete state.nodes[id];
        redrawEdges(); persist();
      }
      function focusNode(id){
        const el = BOARD.querySelector(`.bubble[data-id="${CSS.escape(id)}"] .text`);
        if(el){ el.focus(); placeCaretAtEnd(el); }
      }
      function placeCaretAtEnd(el){
        const r = document.createRange(); r.selectNodeContents(el); r.collapse(false);
        const s = window.getSelection(); s.removeAllRanges(); s.addRange(r);
      }
      function createEdge(fromId, toId){ state.edges.push({ from:fromId, to:toId }); redrawEdges(); persist(); }
      function redrawEdges(){
        EDGES_SVG.innerHTML = '';
        for(const e of state.edges){
          const a = state.nodes[e.from], b = state.nodes[e.to];
          if(!a || !b) continue;
          const p = document.createElementNS('http://www.w3.org/2000/svg','path');
          p.setAttribute('d', cubicPath(centerOf(a), centerOf(b)));
          EDGES_SVG.appendChild(p);
        }
      }
    
      // ---------- Geometry/helpers ----------
      function canvasPos(clientX, clientY){ const r = boardRect(); return { x:clientX - r.left, y:clientY - r.top }; }
      function isOpenSpace(x,y,w,h){
        const br = boardRect();
        if(x < MARGIN || y < MARGIN || (x+w) > (br.width - MARGIN) || (y+h) > (br.height - MARGIN)) return false;
        const rect = { x, y, w, h };
        for(const id in state.nodes){
          const n = state.nodes[id];
          const r2 = { x:n.x - MARGIN, y:n.y - MARGIN, w:n.w + 2*MARGIN, h:n.h + 2*MARGIN };
          if(overlap(rect, r2)) return false;
        }
        return true;
      }
    
      // ---------- Board interactions ----------
      BOARD.addEventListener('mousedown', (e) => {
        // If editing, clicking the canvas should only exit edit mode (no new bubble)
        if(isEditing()){
          if(!e.target.closest('.bubble') && !e.target.closest('.toolbar')){
            e.preventDefault();
            blurActiveText();
          }
          return;
        }
    
        if(e.target.closest('.bubble') || e.target.closest('.toolbar')) return;
        if(e.button !== 0) return;
        e.preventDefault();
        const { x, y } = canvasPos(e.clientX, e.clientY);
        const nx = Math.round(x - DEFAULT_SIZE.w/2);
        const ny = Math.round(y - DEFAULT_SIZE.h/2);
        if(!isOpenSpace(nx, ny, DEFAULT_SIZE.w, DEFAULT_SIZE.h)) return;
        const node = createNode(nx, ny, '', nextColorIdx());
        requestAnimationFrame(() => focusNode(node.id));
      });
    
      document.addEventListener('keydown', (e) => { if(e.key === 'Escape' && linkDrag.active){ cleanupLinkDrag(); } });
    
      // ---------- Toolbar ----------
      IMPORT_BTN.addEventListener('click', () => FILE_INPUT.click());
      FILE_INPUT.addEventListener('change', async () => {
        const file = FILE_INPUT.files && FILE_INPUT.files[0];
        if(!file) return;
        try{
          const data = JSON.parse(await file.text());
          loadData(data, true); persist();
        }catch{ alert('Import failed: invalid JSON'); }
        FILE_INPUT.value = '';
      });
    
      EXPORT_BTN.addEventListener('click', () => {
        const blob = new Blob([JSON.stringify(serializable(), null, 2)], {type:'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `mindmap-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=> URL.revokeObjectURL(a.href), 3000);
      });
    
      CLEAR_BTN.addEventListener('click', () => { clearAll(); persist(); });
    
      if(TITLE_EL){
        TITLE_EL.addEventListener('input', ()=>{ state.title = TITLE_EL.textContent || ''; persist(); });
      }
    
      // ---------- State I/O ----------
      function serializable(){
        return { nodes: Object.values(state.nodes), edges: state.edges, nextColor: state.nextColor, title: state.title };
      }
      function loadData(data, clearFirst=false){
        if(clearFirst) clearAll();
        const nodes = Array.isArray(data.nodes) ? data.nodes : [];
        const edges = Array.isArray(data.edges) ? data.edges : [];
        const nextColor = Number.isFinite(data.nextColor) ? data.nextColor : 0;
    
        for(const n of nodes){
          if(!n || !('id' in n)) continue;
          state.nodes[n.id] = {
            id:n.id, x:+n.x||0, y:+n.y||0, w:+n.w||DEFAULT_SIZE.w, h:+n.h||DEFAULT_SIZE.h,
            text:String(n.text||''), colorIdx: Math.abs(+n.colorIdx||0) % COLORS.length
          };
          const el = makeBubbleEl(state.nodes[n.id]); el.dataset.fresh = '0'; BOARD.appendChild(el);
        }
        state.edges = edges.filter(e=> e && e.from in state.nodes && e.to in state.nodes).map(e=>({from:e.from,to:e.to}));
        state.nextColor = nextColor % COLORS.length;
        state.title = typeof data.title === 'string' ? data.title : '';
        if(TITLE_EL){ TITLE_EL.textContent = state.title; }
        redrawEdges();
      }
      function persist(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(serializable())); }
      function restore(){
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return;
        try{ loadData(JSON.parse(raw), true); }catch{/* ignore */}
      }
      function clearAll(){
        const savedTitle = state.title || '';
        [...BOARD.querySelectorAll('.bubble')].forEach(el=>el.remove());
        state = { nodes:{}, edges:[], nextColor:0, title:savedTitle };
        EDGES_SVG.innerHTML='';
        localStorage.removeItem(STORAGE_KEY);
      }
    
      window.addEventListener('resize', () => redrawEdges());
    
      // ---------- Contrast helpers ----------
      function applyTextContrast(textEl, colorIdx){
        const bg = COLORS[colorIdx] || '#333';
        const white = '#ffffff', dark = '#0f172a';
        const useWhite = contrastRatio(bg, white) >= contrastRatio(bg, dark);
        textEl.style.color = useWhite ? white : dark;
        textEl.style.textShadow = useWhite ? '0 1px 0 #00000025' : 'none';
      }
      function contrastRatio(bgHex, fgHex){
        const L1 = relLum(bgHex), L2 = relLum(fgHex); const [a,b] = L1 >= L2 ? [L1,L2] : [L2,L1];
        return (a + 0.05) / (b + 0.05);
      }
      function relLum(hex){
        const {r,g,b} = hexToRgb(hex);
        const Rs=r/255,Gs=g/255,Bs=b/255;
        const R=Rs<=0.03928?Rs/12.92:Math.pow((Rs+0.055)/1.055,2.4);
        const G=Gs<=0.03928?Gs/12.92:Math.pow((Gs+0.055)/1.055,2.4);
        const B=Bs<=0.03928?Bs/12.92:Math.pow((Bs+0.055)/1.055,2.4);
        return 0.2126*R + 0.7152*G + 0.0722*B;
      }
      function hexToRgb(hex){
        const h = hex.replace('#','');
        const v = parseInt(h.length===3 ? h.split('').map(x=>x+x).join('') : h, 16);
        return { r:(v>>16)&255, g:(v>>8)&255, b:v&255 };
      }
    
      // INIT
      restore();
    })();
    </script>
    
    
    
</body>
</html>
