<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Changemakers Trello — Master → Child List Manager</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />
  <style>
    .board-list { max-height: 300px; overflow: auto; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .smallcaps { font-variant: small-caps; letter-spacing: .5px; }
    .op-card { border-left: 4px solid #0d6efd; }
    .template-list { border: 1px solid rgba(0, 0, 0, .1); border-radius: .5rem; padding: .75rem; margin-bottom: .75rem; background: #fff; }
    .template-list.selected { border-color: #0d6efd; box-shadow: 0 0 0 .15rem rgba(13, 110, 253, .25); }
    .template-list .header { display: flex; justify-content: space-between; align-items: center; gap: .5rem; }
    .template-cards { margin-top: .5rem; max-height: 220px; overflow-y: auto; }
  </style>
</head>
<body class="container py-4">
  <h1 class="mb-3">Changemakers Trello — Master → Child List Manager</h1>
  <p class="text-muted">Copy a list from a master board into many child boards. Existing lists are renamed and archived (hidden), preserving position if desired. Use <strong>Preview</strong> to verify before writing.</p>

  <!-- Credentials & Controls -->
  <div class="card mb-4">
    <div class="card-body">
      <div class="row g-2 align-items-end">
        <div class="col-md-3">
          <label class="form-label">API Key</label>
          <input id="apiKey" class="form-control" placeholder="key" />
        </div>
        <div class="col-md-3">
          <label class="form-label">Token</label>
          <input id="token" class="form-control" placeholder="token" />
        </div>
        <div class="col-md-3">
          <label class="form-label">Current Board (optional)</label>
          <input id="boardId" class="form-control" placeholder="board id to inspect" />
        </div>
        <div class="col-md-3 d-flex gap-2">
          <button id="saveCreds" class="btn btn-outline-secondary w-50">Save</button>
          <button id="loadBoards" class="btn btn-success w-50">Load Boards</button>
        </div>
      </div>
      <div class="form-check form-switch mt-3">
        <input class="form-check-input" type="checkbox" id="dryRun" checked>
        <label class="form-check-label" for="dryRun">Preview only (no writes)</label>
      </div>
    </div>
  </div>

  <!-- Board selector -->
  <div class="row g-4">
    <div class="col-lg-4">
      <div class="card h-100">
        <div class="card-body">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h5 class="card-title mb-0">Boards</h5>
            <div class="btn-group">
              <button id="selectAll" class="btn btn-sm btn-outline-primary">Select all</button>
              <button id="selectNone" class="btn btn-sm btn-outline-secondary">None</button>
            </div>
          </div>
          <input id="boardFilter" class="form-control form-control-sm mb-2" placeholder="Filter boards by name" />
          <div id="boardsContainer" class="board-list"></div>
        </div>
      </div>
    </div>

    <div class="col-lg-8">
      <!-- Template Browser -->
      <div class="card mb-4">
        <div class="card-body">
          <h5 class="card-title smallcaps">Template Browser</h5>
          <p class="mb-2">Load your master board, select a list or specific cards, then copy them into the boards you selected in the sidebar.</p>
          <div class="row g-3 align-items-end">
            <div class="col-md-6">
              <label class="form-label">Template board ID</label>
              <input id="templateBoardId" class="form-control" placeholder="defaults to Current Board field" />
            </div>
            <div class="col-md-6 d-grid gap-2">
              <button id="loadTemplate" class="btn btn-outline-primary">Load Template</button>
              <button id="clearTemplate" class="btn btn-outline-secondary">Clear Selection</button>
              <button id="syncTemplateLabels" class="btn btn-outline-success">Copy Labels to Boards</button>
            </div>
          </div>
          <div id="templateContent" class="mt-3"></div>
          <div id="templateActions" class="mt-3" hidden>
            <div class="row g-3 align-items-end">
              <div class="col-lg-4 col-md-6">
                <label class="form-label">New list name (optional)</label>
                <input id="templateListNameOverride" class="form-control" placeholder="Defaults to template list name" />
              </div>
              <div class="col-lg-4 col-md-6">
                <label class="form-label">Destination list name</label>
                <input id="templateTargetListName" class="form-control" placeholder="Defaults to template list name" />
              </div>
              <div class="col-lg-2 col-md-4">
                <label class="form-label">Card position</label>
                <select id="templateCardPosition" class="form-select">
                  <option value="bottom">Bottom</option>
                  <option value="top">Top</option>
                </select>
              </div>
              <div class="col-lg-2 col-md-4 d-grid gap-2">
                <button id="previewTemplateCopy" class="btn btn-outline-primary">Preview</button>
                <button id="runTemplateCopy" class="btn btn-primary">Copy Selection</button>
              </div>
            </div>
            <div class="row g-3 mt-2 align-items-center">
              <div class="col-md-4 form-check form-switch">
                <input class="form-check-input" type="checkbox" id="templateReplaceCard" checked>
                <label class="form-check-label" for="templateReplaceCard">Replace cards with same name (preserve position)</label>
                <div class="form-text">Disable to copy cards to top/bottom instead.</div>
              </div>
            </div>
            <small class="text-muted d-block mt-2">When copying lists, all cards in those lists come along. For cards, the destination list defaults to the source list name.</small>
          </div>
          <div id="templateStatus" class="text-muted small mt-3"></div>
          <pre id="templateLog" class="mt-2 mono small" style="white-space:pre-wrap"></pre>
        </div>
      </div>
      <!-- Swap Positions Within Boards -->
      <div class="card op-card mb-4">
        <div class="card-body">
          <h5 class="card-title smallcaps">Swap List Positions (per board)</h5>
          <div class="row g-3">
            <div class="col-md-5">
              <input id="swapListA" class="form-control" placeholder="List A name (e.g., Prototype)" />
            </div>
            <div class="col-md-5">
              <input id="swapListB" class="form-control" placeholder="List B name (e.g., Test)" />
            </div>
            <div class="col-md-2 d-grid">
              <button id="swapPositions" class="btn btn-primary">Swap</button>
            </div>
          </div>
          <pre id="logSwap" class="mt-3 mono small" style="white-space:pre-wrap"></pre>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
  <script>
    // ---------- Utilities ----------
    const qs = (s, el=document) => el.querySelector(s);
    const qsa = (s, el=document) => Array.from(el.querySelectorAll(s));
    const val = id => document.getElementById(id).value.trim();
    const dry = () => document.getElementById('dryRun').checked;
    const nowStamp = () => new Date().toISOString().replace('T',' ').slice(0,16);

    const Trello = {
      apiBase: 'https://api.trello.com/1',
      key: () => val('apiKey'),
      token: () => val('token'),
      url(path, params={}) {
        const p = new URLSearchParams({ key: this.key(), token: this.token(), ...params });
        return `${this.apiBase}${path}?${p.toString()}`;
      },
      async get(path, params={}) {
        const r = await fetch(this.url(path, params));
        const t = await r.text();
        try { return { ok: r.ok, data: JSON.parse(t) }; } catch { return { ok: r.ok, data: t }; }
      },
      async post(path, params={}) {
        if (dry()) { console.log('[DRY-RUN] POST', path, params); return { ok: true, data: { dryRun: true } }; }
        const r = await fetch(this.apiBase + path, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ key: this.key(), token: this.token(), ...params })
        });
        const t = await r.text();
        try { return { ok: r.ok, data: JSON.parse(t) }; } catch { return { ok: r.ok, data: t }; }
      },
      async put(path, params={}) {
        if (dry()) { console.log('[DRY-RUN] PUT', path, params); return { ok: true, data: { dryRun: true } }; }
        const r = await fetch(this.apiBase + path, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ key: this.key(), token: this.token(), ...params })
        });
        const t = await r.text();
        try { return { ok: r.ok, data: JSON.parse(t) }; } catch { return { ok: r.ok, data: t }; }
      }
    };

    // ---------- State ----------
    let ALL_BOARDS = [];
    let TEMPLATE_STATE = { boardId: null, lists: [], labels: [] };
    let TEMPLATE_SELECTION = { type: null, listIds: [], cards: [] };
    let BOARD_LABEL_CACHE = {};

    // ---------- Init ----------
    document.addEventListener('DOMContentLoaded', () => {
      // restore creds
      const map = { apiKey: 'trelloApiKey', token: 'trelloToken', boardId: 'trelloBoardId' };
      Object.entries(map).forEach(([id, k]) => { const v = localStorage.getItem(k); if (v) document.getElementById(id).value = v; });
      const savedBoardId = document.getElementById('boardId').value.trim();
      if (savedBoardId) document.getElementById('templateBoardId').value = savedBoardId;

      // wire buttons
      qs('#saveCreds').addEventListener('click', () => {
        localStorage.setItem('trelloApiKey', val('apiKey'));
        localStorage.setItem('trelloToken', val('token'));
        localStorage.setItem('trelloBoardId', val('boardId'));
        alert('Saved.');
      });
      qs('#loadBoards').addEventListener('click', loadBoards);
      qs('#selectAll').addEventListener('click', () => qsa('.board-check').forEach(cb => cb.checked = true));
      qs('#selectNone').addEventListener('click', () => qsa('.board-check').forEach(cb => cb.checked = false));
      qs('#boardFilter').addEventListener('input', filterBoards);
      qs('#loadTemplate').addEventListener('click', loadTemplateBoard);
      qs('#clearTemplate').addEventListener('click', clearTemplateBrowser);
      qs('#syncTemplateLabels').addEventListener('click', copyTemplateLabelsToBoards);
      qs('#templateContent').addEventListener('change', handleTemplateSelectionChange);
      qs('#previewTemplateCopy').addEventListener('click', () => copyTemplateSelection(true));
      qs('#runTemplateCopy').addEventListener('click', () => copyTemplateSelection(false));
      const replaceSwitch = qs('#templateReplaceCard');
      if (replaceSwitch) replaceSwitch.addEventListener('change', () => updateTemplateSelectionUI());
      qs('#swapPositions').addEventListener('click', swapPositionsAcrossBoards);
    });

    // ---------- Boards UI ----------
    async function loadBoards() {
      const params = {
        filter: 'open',
        fields: 'name,closed,starred,url',
        memberships: 'me'
      };
      const { ok, data } = await Trello.get('/members/me/boards', params);
      if (!ok) return alert('Failed to load boards: ' + data);
      const boards = (data || []).filter(b => !b.closed && (Boolean(b.starred) || isBoardAdmin(b)));
      boards.sort((a, b) => {
        const starDiff = Number(Boolean(b.starred)) - Number(Boolean(a.starred));
        if (starDiff) return starDiff;
        const adminDiff = Number(isBoardAdmin(b)) - Number(isBoardAdmin(a));
        if (adminDiff) return adminDiff;
        return (a.name || '').localeCompare(b.name || '');
      });
      ALL_BOARDS = boards;
      renderBoardList(boards);
      qs('#templateStatus').textContent = boards.length
        ? `Loaded ${boards.length} boards visible on your Trello dashboard (starred or admin).`
        : 'No matching boards found. Star a board or ensure you are an admin to see it here.';
    }

    function renderBoardList(boards) {
      const container = qs('#boardsContainer');
      container.innerHTML = boards.map(b => `
        <div class="form-check">
          <input class="form-check-input board-check" type="checkbox" id="b-${b.id}" value="${b.id}">
          <label class="form-check-label" for="b-${b.id}">
            ${b.starred ? '★ ' : ''}${escapeHtml(b.name)}
            ${isBoardAdmin(b) ? '<span class="badge bg-secondary ms-1">admin</span>' : ''}
            <span class="text-muted mono ms-1">(${b.id})</span>
          </label>
        </div>`).join('');
    }

    function filterBoards(e) {
      const q = e.target.value.toLowerCase();
      const filtered = ALL_BOARDS.filter(b => (b.name || '').toLowerCase().includes(q));
      renderBoardList(filtered);
    }

    function isBoardAdmin(board) {
      return (board && board.memberships || []).some(m => {
        const type = (m.memberType || m.type || '').toLowerCase();
        return type === 'admin';
      });
    }

    function selectedBoardIds() { return qsa('.board-check:checked').map(cb => cb.value); }
    function escapeHtml(s='') { return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
    function norm(s='') { return s.trim().toLowerCase(); }

    function normalizeLabel(label={}) {
      return {
        id: label.id,
        name: (label.name || '').trim(),
        color: label.color ?? null
      };
    }

    function normalizeLabels(labels=[]) { return labels.map(normalizeLabel); }

    function labelKey(label={}) {
      const color = (label.color || 'none').toString().toLowerCase();
      const name = (label.name || '').trim().toLowerCase();
      return `${color}|${name}`;
    }

    function labelDesc(label={}) {
      const parts = [];
      if (label.name) parts.push(`"${label.name}"`);
      if (label.color) parts.push(label.color);
      return parts.length ? parts.join(' ') : 'unnamed label';
    }

    function uniqueLabels(labels=[]) {
      const seen = new Set();
      const out = [];
      for (const label of labels) {
        const key = labelKey(label);
        if (!key || seen.has(key)) continue;
        seen.add(key);
        out.push(label);
      }
      return out;
    }

    // ---------- Helpers ----------
    async function getLists(boardId) {
      const { ok, data } = await Trello.get(`/boards/${boardId}/lists`);
      if (!ok) throw new Error('Lists error: ' + data);
      return data;
    }

    async function findListByName(boardId, name) {
      const lists = await getLists(boardId);
      return lists.find(l => norm(l.name) === norm(name));
    }

    async function renameList(listId, newName) {
      return Trello.put(`/lists/${listId}`, { name: newName });
    }

    async function setListPos(listId, pos) {
      return Trello.put(`/lists/${listId}/pos`, { value: String(pos) });
    }

    async function archiveList(listId) {
      return Trello.put(`/lists/${listId}/closed`, { value: true });
    }

    async function getListById(listId) {
      const res = await Trello.get(`/lists/${listId}`, { fields: 'name,color,pos,closed' });
      if (!res.ok) throw new Error('Get list failed: ' + res.data);
      return res.data;
    }

    async function setListColor(listId, color) {
      return Trello.put(`/lists/${listId}/color`, { value: color });

    }

    async function getCards(listId) {
      const { ok, data } = await Trello.get(`/lists/${listId}/cards`, { fields: 'id,name,pos' });
      if (!ok) throw new Error('Cards error: ' + data);
      return data;
    }

    async function archiveCard(cardId) {
      return Trello.put(`/cards/${cardId}/closed`, { value: true });
    }

    function bucketCardsByName(cards=[]) {
      const map = new Map();
      const sorted = [...cards].sort((a, b) => (a.pos || 0) - (b.pos || 0));
      for (const card of sorted) {
        const key = norm(card.name || '');
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(card);
      }
      return map;
    }

    function formatError(err) {
      if (!err) return 'unknown error';
      if (typeof err === 'string') return err;
      try { return JSON.stringify(err); } catch { return String(err); }
    }

    async function loadBoardLabelCache(boardId) {
      if (BOARD_LABEL_CACHE[boardId]) return BOARD_LABEL_CACHE[boardId];
      const res = await Trello.get(`/boards/${boardId}/labels`, { limit: 1000, fields: 'name,color' });
      if (!res.ok) {
        BOARD_LABEL_CACHE[boardId] = { map: {}, labels: [], error: formatError(res.data) };
      } else {
        const map = {};
        (res.data || []).forEach(lbl => { map[labelKey(lbl)] = lbl.id; });
        BOARD_LABEL_CACHE[boardId] = { map, labels: res.data, error: null };
      }
      return BOARD_LABEL_CACHE[boardId];
    }

    async function ensureBoardLabelIds(boardId, labels, log, simulate=false) {
      const cache = await loadBoardLabelCache(boardId);
      if (cache.error) {
        return { mapping: {}, missing: labels.map(labelDesc), error: cache.error };
      }
      const mapping = {};
      const missing = [];
      const uniques = uniqueLabels(labels);
      for (const label of uniques) {
        const key = labelKey(label);
        if (!key) continue;
        if (cache.map[key]) {
          mapping[key] = cache.map[key];
          continue;
        }
        if (simulate || dry()) {
          missing.push(labelDesc(label));
          continue;
        }
        const payload = { idBoard: boardId };
        if (label.name) payload.name = label.name;
        if (label.color) payload.color = label.color;
        const create = await Trello.post('/labels', payload);
        if (!create.ok) {
          const msg = formatError(create.data);
          log.push(`  ✖ Failed to create label ${labelDesc(label)} on board ${boardId}: ${msg}`);
          missing.push(labelDesc(label));
          continue;
        }
        const newId = create.data?.id;
        if (newId) {
          cache.map[key] = newId;
          if (Array.isArray(cache.labels)) cache.labels.push({ id: newId, name: label.name || '', color: label.color || null });
          mapping[key] = newId;
          log.push(`  Created label ${labelDesc(label)} on board ${boardId}.`);
        } else {
          missing.push(labelDesc(label));
        }
      }
      return { mapping, missing, error: null };
    }

    async function applyLabelsToCard({ boardId, cardId, labels, cardName, log, simulate=false }) {
      const normalized = uniqueLabels(normalizeLabels(labels || []));
      if (!normalized.length) return;
      const summary = normalized.map(labelDesc).join(', ');
      const { mapping, missing, error } = await ensureBoardLabelIds(boardId, normalized, log, simulate);
      if (error) {
        log.push(`  ✖ Could not sync labels for "${cardName}": ${error}`);
        return;
      }
      if (simulate || dry()) {
        if (missing.length) {
          log.push(`  Would apply labels to "${cardName}": ${summary} (needs new: ${missing.join(', ')}).`);
        } else {
          log.push(`  Would apply labels to "${cardName}": ${summary}.`);
        }
        return;
      }
      if (!cardId) {
        log.push(`  ⚠ Unable to set labels on "${cardName}" (missing card id).`);
        return;
      }
      let failures = 0;
      const skipped = [];
      for (const label of normalized) {
        const key = labelKey(label);
        const labelId = mapping[key];
        if (!labelId) {
          skipped.push(labelDesc(label));
          continue;
        }
        const res = await Trello.post(`/cards/${cardId}/idLabels`, { value: labelId });
        if (!res.ok) {
          failures += 1;
          log.push(`  ✖ Failed to apply label ${labelDesc(label)}: ${formatError(res.data)}`);
        }
      }
      if (!missing.length && !skipped.length && !failures) {
        log.push(`  Applied labels to "${cardName}": ${summary}.`);
      } else {
        const notes = [];
        if (missing.length) notes.push(`needed new: ${missing.join(', ')}`);
        if (skipped.length) notes.push(`unavailable: ${skipped.join(', ')}`);
        if (failures) notes.push(`${failures} apply request(s) failed`);
        log.push(`  ⚠ Label sync issues for "${cardName}": ${notes.join('; ')}.`);
      }
    }

    async function syncListCardLabels({ boardId, targetListId, sourceCards=[], log, simulate=false }) {
      const cardsWithLabels = sourceCards.filter(card => (card.labels || []).length);
      if (!cardsWithLabels.length) return;
      const effectiveSim = simulate || dry();
      if (effectiveSim) {
        const labelCount = cardsWithLabels.reduce((acc, card) => acc + (card.labels?.length || 0), 0);
        log.push(`  Would sync ${labelCount} label(s) across ${cardsWithLabels.length} card(s).`);
        return;
      }
      if (!targetListId) {
        log.push('  ⚠ Unable to sync labels for copied list (missing new list id).');
        return;
      }
      let targetCards = [];
      try {
        targetCards = await getCards(targetListId);
      } catch (err) {
        log.push(`  ✖ Failed to read copied list cards for label sync: ${formatError(err?.message || err)}`);
        return;
      }
      if (!targetCards.length) return;
      const sourceBuckets = bucketCardsByName(cardsWithLabels);
      const sortedTargets = [...targetCards].sort((a, b) => (a.pos || 0) - (b.pos || 0));
      for (const t of sortedTargets) {
        const key = norm(t.name || '');
        const bucket = sourceBuckets.get(key);
        if (!bucket || !bucket.length) continue;
        const sourceCard = bucket.shift();
        if (!sourceCard || !(sourceCard.labels || []).length) continue;
        await applyLabelsToCard({
          boardId,
          cardId: t.id,
          labels: sourceCard.labels,
          cardName: t.name || sourceCard.name || '(no name)',
          log,
          simulate: false
        });
      }
    }

    // ---------- Template Browser ----------
    async function loadTemplateBoard() {
      const typed = val('templateBoardId') || val('boardId');
      if (!typed) return alert('Provide a template board ID first.');
      qs('#templateStatus').textContent = 'Loading template board…';
      const { ok, data } = await Trello.get(`/boards/${typed}/lists`, {
        cards: 'open',
        card_fields: 'name,pos',
        card_labels: 'all',
        fields: 'name,pos,color'
      });
      const labelRes = await Trello.get(`/boards/${typed}/labels`, { limit: 1000, fields: 'name,color' });
      if (!ok) {
        qs('#templateStatus').textContent = 'Failed to load template board.';
        return alert('Failed to load template board: ' + data);
      }
      if (!labelRes.ok) {
        qs('#templateStatus').textContent = 'Loaded template lists, but failed to load labels.';
      }
      const boardLabels = labelRes.ok ? normalizeLabels(labelRes.data || []) : [];
      TEMPLATE_STATE = {
        boardId: typed,
        labels: boardLabels,
        lists: (data || []).map(l => ({
          id: l.id,
          name: l.name,
          pos: l.pos,
          cards: (l.cards || []).map(card => ({
            id: card.id,
            name: card.name,
            pos: card.pos,
            labels: normalizeLabels(card.labels || []),
            listId: l.id
          }))
        }))
      };
      if (labelRes.ok) {
        BOARD_LABEL_CACHE[typed] = {
          map: Object.fromEntries(boardLabels.map(lbl => [labelKey(lbl), lbl.id])),
          labels: boardLabels,
          error: null
        };
      }
      TEMPLATE_SELECTION = { type: null, listIds: [], cards: [] };
      renderTemplateLists(TEMPLATE_STATE.lists);
      qs('#templateLog').textContent = '';
      const boardInput = document.getElementById('boardId');
      if (boardInput && !boardInput.value.trim()) boardInput.value = typed;
      const templateInput = document.getElementById('templateBoardId');
      if (templateInput) templateInput.value = typed;
      updateTemplateSelectionUI();
      qs('#templateStatus').textContent = TEMPLATE_STATE.lists.length
        ? `Loaded ${TEMPLATE_STATE.lists.length} open list(s). Select a list or cards to continue.`
        : 'The template board has no open lists.';
    }

    function renderTemplateLists(lists) {
      const container = qs('#templateContent');
      if (!container) return;
      container.innerHTML = lists.map(list => {
        const listChecked = TEMPLATE_SELECTION.type === 'lists' && (TEMPLATE_SELECTION.listIds || []).includes(list.id);
        const cards = list.cards && list.cards.length
          ? list.cards.map(card => `
            <div class="form-check">
              <input class="form-check-input template-card-check" type="checkbox" id="card-${card.id}" data-card-id="${card.id}" data-card-name="${escapeHtml(card.name || '(no name)')}" data-list-id="${list.id}" ${isCardSelected(card.id) ? 'checked' : ''}>
              <label class="form-check-label" for="card-${card.id}">${escapeHtml(card.name || '(no name)')}</label>
            </div>`).join('')
          : '<div class="text-muted small">No open cards</div>';
        return `
          <div class="template-list ${listChecked ? 'selected' : ''}" data-list-id="${list.id}">
            <div class="header">
              <div class="form-check mb-0">
                <input class="form-check-input template-list-check" type="checkbox" id="tmpl-${list.id}" data-list-id="${list.id}" ${listChecked ? 'checked' : ''}>
                <label class="form-check-label" for="tmpl-${list.id}"><strong>${escapeHtml(list.name || '(no name)')}</strong></label>
              </div>
              <span class="badge bg-light text-dark">${(list.cards && list.cards.length) || 0} cards</span>
            </div>
            <div class="template-cards" data-list-id="${list.id}">
              ${cards}
            </div>
          </div>`;
      }).join('');
      qs('#templateActions').hidden = !lists.length;
    }

    function isCardSelected(cardId) {
      return TEMPLATE_SELECTION.type === 'cards' && (TEMPLATE_SELECTION.cards || []).some(c => c.id === cardId);
    }

    function handleTemplateSelectionChange(e) {
      const el = e.target;
      if (el.classList.contains('template-list-check')) {
        if (el.checked) {
          // Switching to list mode clears any card selections
          qsa('.template-card-check').forEach(cb => cb.checked = false);
          const selectedIds = new Set(TEMPLATE_SELECTION.type === 'lists' ? TEMPLATE_SELECTION.listIds : []);
          selectedIds.add(el.dataset.listId);
          TEMPLATE_SELECTION = { type: 'lists', listIds: Array.from(selectedIds), cards: [] };
        } else {
          const remainder = qsa('.template-list-check:checked').map(cb => cb.dataset.listId);
          TEMPLATE_SELECTION = remainder.length ? { type: 'lists', listIds: remainder, cards: [] } : { type: null, listIds: [], cards: [] };
        }
      } else if (el.classList.contains('template-card-check')) {
        if (el.checked) {
          qsa('.template-list-check').forEach(cb => cb.checked = false);
        }
        let checked = qsa('.template-card-check:checked');
        if (!checked.length) {
          TEMPLATE_SELECTION = { type: null, listIds: [], cards: [] };
        } else {
          let listIds = Array.from(new Set(checked.map(cb => cb.dataset.listId)));
          if (listIds.length > 1) {
            alert('Select cards from only one list at a time.');
            el.checked = false;
            checked = qsa('.template-card-check:checked');
            if (!checked.length) {
              TEMPLATE_SELECTION = { type: null, listIds: [], cards: [] };
              updateTemplateSelectionUI();
              return;
            }
            listIds = Array.from(new Set(checked.map(cb => cb.dataset.listId)));
          }
          const cards = checked.map(cb => ({
            id: cb.dataset.cardId,
            listId: cb.dataset.listId,
            name: cb.dataset.cardName || ''
          }));
          TEMPLATE_SELECTION = { type: 'cards', listIds, cards };
        }
      }
      updateTemplateSelectionUI();
    }

    function clearTemplateBrowser() {
      TEMPLATE_SELECTION = { type: null, listIds: [], cards: [] };
      qsa('.template-list-check').forEach(r => { r.checked = false; r.closest('.template-list')?.classList.remove('selected'); });
      qsa('.template-card-check').forEach(cb => { cb.checked = false; cb.closest('.template-list')?.classList.remove('selected'); });
      const listOverride = document.getElementById('templateListNameOverride');
      const targetInput = document.getElementById('templateTargetListName');
      if (listOverride) listOverride.value = '';
      if (targetInput) targetInput.value = '';
      qs('#templateLog').textContent = '';
      updateTemplateSelectionUI();
    }

    function updateTemplateSelectionUI() {
      const statusEl = qs('#templateStatus');
      const listNameInput = document.getElementById('templateListNameOverride');
      const targetListInput = document.getElementById('templateTargetListName');
      const cardPosSelect = document.getElementById('templateCardPosition');
      const replaceSwitch = document.getElementById('templateReplaceCard');
      qsa('.template-list').forEach(el => el.classList.remove('selected'));

      let status = TEMPLATE_STATE.lists.length
        ? 'Select a list or specific cards from the template.'
        : 'Load a template board to begin.';

      if (listNameInput) {
        listNameInput.disabled = false;
        if (!listNameInput.value) listNameInput.placeholder = 'Defaults to template list name';
      }
      if (targetListInput) {
        targetListInput.disabled = false;
        if (!targetListInput.value) targetListInput.placeholder = 'Defaults to template list name';
      }
      if (cardPosSelect) cardPosSelect.disabled = false;
      if (replaceSwitch) replaceSwitch.disabled = false;

      if (TEMPLATE_SELECTION.type === 'lists' && TEMPLATE_SELECTION.listIds.length) {
        const names = [];
        TEMPLATE_SELECTION.listIds.forEach(id => {
          const node = qs(`.template-list[data-list-id="${id}"]`);
          if (node) node.classList.add('selected');
          const list = TEMPLATE_STATE.lists.find(l => l.id === id);
          if (list) names.push(list.name || '(no name)');
        });
        status = `Lists selected: ${names.join(', ')}. All cards in those lists will be copied.`;
        if (listNameInput) {
          if (TEMPLATE_SELECTION.listIds.length > 1) {
            listNameInput.disabled = true;
            listNameInput.placeholder = 'Rename available when a single list is selected';
          } else if (!listNameInput.value) {
            const single = TEMPLATE_STATE.lists.find(l => l.id === TEMPLATE_SELECTION.listIds[0]);
            if (single) listNameInput.placeholder = `Defaults to "${single.name}"`;
          }
        }
        if (targetListInput) {
          targetListInput.value = '';
          targetListInput.disabled = true;
        }
        if (cardPosSelect) cardPosSelect.disabled = true;
        if (replaceSwitch) {
          replaceSwitch.checked = true;
          replaceSwitch.disabled = true;
        }
      } else if (TEMPLATE_SELECTION.type === 'cards' && TEMPLATE_SELECTION.cards.length) {
        const listId = TEMPLATE_SELECTION.listIds[0];
        const list = TEMPLATE_STATE.lists.find(l => l.id === listId);
        if (list) {
          const node = qs(`.template-list[data-list-id="${list.id}"]`);
          if (node) node.classList.add('selected');
          status = `Cards selected (${TEMPLATE_SELECTION.cards.length}) from "${list.name}".`;
          if (targetListInput && !targetListInput.value) targetListInput.value = list.name || '';
          if (targetListInput && !targetListInput.value) targetListInput.placeholder = list.name || '';
          if (listNameInput && !listNameInput.value) listNameInput.placeholder = `Defaults to "${list.name}"`;
        } else {
          status = `Cards selected: ${TEMPLATE_SELECTION.cards.length}.`;
        }
      }

      if (statusEl) statusEl.textContent = status;
    }

    function findTemplateCard(cardId) {
      for (const list of TEMPLATE_STATE.lists) {
        const match = (list.cards || []).find(card => card.id === cardId);
        if (match) return { ...match, listId: list.id };
      }
      return null;
    }

    async function copyTemplateLabelsToBoards() {
      if (!TEMPLATE_STATE.boardId) return alert('Load a template board first.');
      const templateLabels = TEMPLATE_STATE.labels || [];
      if (!templateLabels.length) return alert('Template board has no labels to copy.');
      const bids = selectedBoardIds();
      if (!bids.length) return alert('Select one or more boards to receive labels.');
      const log = [];
      for (const bid of bids) {
        log.push(`\n— Board ${bid}`);
        try {
          const { mapping, missing, error } = await ensureBoardLabelIds(bid, templateLabels, log, dry());
          if (error) {
            log.push(`  ✖ Failed to sync labels: ${error}`);
            continue;
          }
          const total = Object.keys(mapping || {}).length;
          if (dry()) {
            log.push(`  Would ensure ${total} label(s) exist on this board.`);
            if (missing.length) log.push(`  Still missing (dry-run): ${missing.join(', ')}`);
          } else if (missing.length) {
            log.push(`  ⚠ Some labels could not be created: ${missing.join(', ')}`);
          } else {
            log.push('  Labels synced successfully.');
          }
        } catch (err) {
          log.push(`  ✖ Error: ${formatError(err?.message || err)}`);
        }
      }
      const current = qs('#templateLog').textContent || '';
      qs('#templateLog').textContent = `${current}\n=== Label Sync ===${log.join('\n')}`.trim();
    }

    async function copyTemplateSelection(preview=false) {
      if (!TEMPLATE_STATE.lists.length) return alert('Load a template board first.');
      const bids = selectedBoardIds();
      if (!bids.length) return alert('Select one or more boards to receive the copy.');
      if (!TEMPLATE_SELECTION.type) return alert('Select a list or at least one card from the template.');
      const log = [];

      if (TEMPLATE_SELECTION.type === 'lists') {
        const override = document.getElementById('templateListNameOverride').value.trim();
        const singleOverride = override && TEMPLATE_SELECTION.listIds.length === 1;
        const simulateLists = preview || dry();
        for (const bid of bids) {
          log.push(`\n— Board ${bid}`);
          for (const listId of TEMPLATE_SELECTION.listIds) {
            const list = TEMPLATE_STATE.lists.find(l => l.id === listId);
            if (!list) { log.push(`  ✖ Template list ${listId} not found. Reload template.`); continue; }
            const newName = singleOverride ? override : list.name;
            const sourceCards = list.cards || [];
            let existingList = null;
            try {
              existingList = await findListByName(bid, newName);
            } catch (err) {
              log.push(`  ✖ Failed to inspect lists on ${bid}: ${err.message}`);
            }
            const existingPos = existingList ? existingList.pos : null;
            const archiveName = existingList ? `${existingList.name} (old ${nowStamp()})` : null;
            if (simulateLists) {
              log.push(`  Would copy list "${list.name}" as "${newName}".`);
              if (list.color) log.push(`  Would set list color to ${list.color}.`);
              if (existingList) {
                log.push(`  Would rename existing list "${existingList.name}" → "${archiveName}" and archive it.`);
                if (existingPos) log.push(`  Would place new list at position ${existingPos}.`);
              } else {
                log.push('  No list with that name exists; new list would be added to the end.');
              }
              await syncListCardLabels({ boardId: bid, targetListId: null, sourceCards, log, simulate: true });
              continue;
            }
            const res = await Trello.post('/lists', { idBoard: bid, idListSource: list.id, name: newName });
            if (!res.ok) { log.push(`  ✖ ${list.name}: ${res.data}`); continue; }
            const newListId = res.data && !res.data.dryRun ? res.data.id : null;
            log.push(`  Copied list "${list.name}" as "${newName}".`);
            if (existingList) {
              const renameRes = await renameList(existingList.id, archiveName);
              if (!renameRes.ok) {
                log.push(`  ⚠ Failed to rename existing list "${existingList.name}": ${renameRes.data}`);
              } else {
                const archiveRes = await archiveList(existingList.id);
                if (!archiveRes.ok) log.push(`  ⚠ Failed to archive "${archiveName}": ${archiveRes.data}`);
                else log.push(`  Archived old list as "${archiveName}".`);
              }
            }
            if (list.color && newListId) {
              const colorRes = await setListColor(newListId, list.color);
              if (colorRes.ok) log.push(`  Set list color to ${list.color}.`);
              else log.push(`  ⚠ Failed to set list color (${list.color}): ${formatError(colorRes.data)}`);
            } else if (list.color && !newListId) {
              log.push(`  ⚠ Could not set list color ${list.color} (missing new list id).`);
            }
            if (newListId && existingPos) {
              const posRes = await setListPos(newListId, existingPos);
              if (posRes.ok) log.push(`  Placed list at preserved position ${existingPos}.`);
              else log.push(`  ⚠ Failed to preserve list position: ${posRes.data}`);
            }
            await syncListCardLabels({ boardId: bid, targetListId: newListId, sourceCards, log, simulate: false });
          }
        }
      } else if (TEMPLATE_SELECTION.type === 'cards') {
        const sourceListId = TEMPLATE_SELECTION.listIds[0];
        const sourceList = TEMPLATE_STATE.lists.find(l => l.id === sourceListId);
        const cards = TEMPLATE_SELECTION.cards.map(sel => findTemplateCard(sel.id)).filter(Boolean);
        if (!cards.length) return alert('Selected cards could not be resolved. Reload template.');

        const targetInput = document.getElementById('templateTargetListName');
        let targetName = targetInput.value.trim();
        if (!targetName && sourceList) {
          targetName = sourceList.name || '';
          if (targetInput) targetInput.value = targetName;
        }
        if (!targetName) return alert('Provide a destination list name to copy cards.');

        const pos = document.getElementById('templateCardPosition').value || 'bottom';
        const replaceExisting = qs('#templateReplaceCard')?.checked ?? true;
        const listCardCache = {};

        for (const bid of bids) {
          log.push(`\n— Board ${bid}`);
          let targetList = null;
          try {
            targetList = await findListByName(bid, targetName);
          } catch (err) {
            log.push(`  ✖ Failed to read lists: ${err.message}`);
            continue;
          }
          if (!targetList) {
            log.push(`  ✖ Destination list "${targetName}" not found.`);
            continue;
          }

          const cacheKey = `${bid}:${targetList.id}`;
          if (!listCardCache[cacheKey]) {
            if (replaceExisting) {
              try {
                const cardsOnList = await getCards(targetList.id);
                listCardCache[cacheKey] = { cards: cardsOnList, error: null };
              } catch (err) {
                log.push(`  ✖ Failed to read cards on "${targetList.name}": ${err.message}`);
                listCardCache[cacheKey] = { cards: [], error: err.message || 'unknown error' };
              }
            } else {
              listCardCache[cacheKey] = { cards: [], error: null };
            }
          }

          for (const card of cards) {
            const cacheEntry = listCardCache[cacheKey] || { cards: [], error: null };
            const lookupFailed = replaceExisting && Boolean(cacheEntry.error);
            const existingCards = replaceExisting && !lookupFailed ? cacheEntry.cards : [];
            const existingCard = replaceExisting && !lookupFailed ? existingCards.find(c => norm(c.name) === norm(card.name)) : null;
            const simulateLabels = preview || dry();
            const cardLabels = card.labels || [];

            if (lookupFailed) {
              if (preview) {
                log.push(`  Unable to check for existing "${card.name}" (failed to load cards). Will copy using "${pos}" position.`);
              } else {
                log.push(`  Unable to check for existing "${card.name}" (failed to load cards). Copying using "${pos}" position.`);
              }
            }

            if (replaceExisting && existingCard) {
              if (preview) {
                log.push(`  Would replace "${card.name}" at its current position.`);
                await applyLabelsToCard({ boardId: bid, cardId: null, labels: cardLabels, cardName: card.name, log, simulate: true });
                continue;
              }
              const res = await Trello.post('/cards', {
                idList: targetList.id,
                idCardSource: card.id,
                keepFromSource: 'all',
                pos: existingCard.pos
              });
              if (!res.ok) {
                log.push(`  ✖ ${card.name}: ${res.data}`);
                continue;
              }
              const newCardId = res.data && res.data.id ? res.data.id : null;
              await applyLabelsToCard({
                boardId: bid,
                cardId: newCardId,
                labels: cardLabels,
                cardName: card.name,
                log,
                simulate: simulateLabels || !newCardId
              });
              const archive = await archiveCard(existingCard.id);
              if (!archive.ok) {
                log.push(`  ⚠ Copied "${card.name}", but failed to archive existing card: ${archive.data}`);
              } else {
                log.push(`  Replaced card "${card.name}".`);
              }
              if (!simulateLabels && newCardId) {
                const idx = existingCards.findIndex(c => c.id === existingCard.id);
                if (idx >= 0) existingCards.splice(idx, 1);
                existingCards.push({ id: newCardId, name: (res.data && res.data.name) || card.name, pos: existingCard.pos });
              }
              continue;
            }

            if (replaceExisting && !existingCard && !lookupFailed) {
              if (preview) {
                log.push(`  No existing card named "${card.name}". Would copy using "${pos}" position.`);
                await applyLabelsToCard({ boardId: bid, cardId: null, labels: cardLabels, cardName: card.name, log, simulate: true });
                continue;
              }
              log.push(`  No existing card named "${card.name}". Copying using "${pos}" position.`);
            }

            if (preview) {
              log.push(`  Would copy card "${card.name}" to "${targetList.name}" (${pos}).`);
              await applyLabelsToCard({ boardId: bid, cardId: null, labels: cardLabels, cardName: card.name, log, simulate: true });
              continue;
            }
            const res = await Trello.post('/cards', {
              idList: targetList.id,
              idCardSource: card.id,
              keepFromSource: 'all',
              pos
            });
            if (!res.ok) {
              log.push(`  ✖ ${card.name}: ${res.data}`);
            } else {
              log.push(`  Copied card "${card.name}" to "${targetList.name}".`);
              const newCardId = res.data && res.data.id ? res.data.id : null;
              await applyLabelsToCard({
                boardId: bid,
                cardId: newCardId,
                labels: cardLabels,
                cardName: card.name,
                log,
                simulate: simulateLabels || !newCardId
              });
              if (!simulateLabels && cacheEntry && !cacheEntry.error && newCardId) {
                cacheEntry.cards.push({ id: newCardId, name: (res.data && res.data.name) || card.name, pos: res.data?.pos || pos });
              }
            }
          }
        }
      }

      qs('#templateLog').textContent = log.join('\n');
    }

    // ---------- Swap list positions within boards ----------
    async function swapPositionsAcrossBoards() {
      const a = val('swapListA');
      const b = val('swapListB');
      if (!a || !b) return alert('Provide both list names.');
      const bids = selectedBoardIds();
      if (!bids.length) return alert('Select boards.');
      const log = [];

      for (const bid of bids) {
        const lists = await getLists(bid);
        const A = lists.find(l => norm(l.name) === norm(a));
        const B = lists.find(l => norm(l.name) === norm(b));
        if (!A || !B) { log.push(`\n— Board ${bid}: missing list(s)`); continue; }
        const apos = A.pos, bpos = B.pos;
        log.push(`\n— Board ${bid}: swap ${A.name} (pos ${apos}) ↔ ${B.name} (pos ${bpos})`);
        if (!dry()) {
          // safe swap: move A to top, B to A's pos, A to B's pos
          await setListPos(A.id, 'top');
          await setListPos(B.id, apos);
          await setListPos(A.id, bpos);
        }
      }
      qs('#logSwap').textContent = log.join('\n');
    }
  </script>
</body>
</html>
